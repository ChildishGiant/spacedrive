/* eslint-disable */
export type Object = NonNullable<FilePathWithObject['object']>;
// This file was generated by [rspc](https://github.com/oscartbeaumont/rspc). Do not edit this file manually.
export type Procedures = { queries: { key: "auth.me"; input: never; result: null; error: SdError } | { key: "backups.getAll"; input: never; result: GetAll; error: SdError } | { key: "buildInfo"; input: never; result: BuildInfo; error: SdError } | { key: "categories.list"; input: LibraryArgs<null>; result: { [key in Category]: number }; error: SdError } | { key: "files.get"; input: LibraryArgs<GetArgs>; result: { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; file_paths: FilePath[] } | null; error: SdError } | { key: "files.getConvertableImageExtensions"; input: never; result: string[]; error: SdError } | { key: "files.getEphemeralMediaData"; input: string; result: ({ type: "Image" } & ImageMetadata) | ({ type: "Video" } & VideoMetadata) | ({ type: "Audio" } & AudioMetadata) | null; error: SdError } | { key: "files.getMediaData"; input: LibraryArgs<number>; result: MediaMetadata; error: SdError } | { key: "files.getPath"; input: LibraryArgs<number>; result: string | null; error: SdError } | { key: "invalidation.test-invalidate"; input: never; result: number; error: SdError } | { key: "jobs.isActive"; input: LibraryArgs<null>; result: boolean; error: SdError } | { key: "jobs.reports"; input: LibraryArgs<null>; result: JobGroup[]; error: SdError } | { key: "library.list"; input: never; result: LibraryConfigWrapped[]; error: SdError } | { key: "library.statistics"; input: LibraryArgs<null>; result: Statistics; error: SdError } | { key: "locations.get"; input: LibraryArgs<number>; result: { id: number; pub_id: number[]; name: string | null; path: string | null; total_capacity: number | null; available_capacity: number | null; size_in_bytes: number[] | null; is_archived: boolean | null; generate_preview_media: boolean | null; sync_preview_media: boolean | null; hidden: boolean | null; date_created: string | null; instance_id: number | null } | null; error: SdError } | { key: "locations.getWithRules"; input: LibraryArgs<number>; result: { id: number; pub_id: number[]; name: string | null; path: string | null; total_capacity: number | null; available_capacity: number | null; size_in_bytes: number[] | null; is_archived: boolean | null; generate_preview_media: boolean | null; sync_preview_media: boolean | null; hidden: boolean | null; date_created: string | null; instance_id: number | null; indexer_rules: { indexer_rule: IndexerRule }[] } | null; error: SdError } | { key: "locations.indexer_rules.get"; input: LibraryArgs<number>; result: IndexerRule; error: SdError } | { key: "locations.indexer_rules.list"; input: LibraryArgs<null>; result: IndexerRule[]; error: SdError } | { key: "locations.indexer_rules.listForLocation"; input: LibraryArgs<number>; result: IndexerRule[]; error: SdError } | { key: "locations.list"; input: LibraryArgs<null>; result: Location[]; error: SdError } | { key: "locations.systemLocations"; input: never; result: SystemLocations; error: SdError } | { key: "nodeState"; input: never; result: NodeState; error: SdError } | { key: "nodes.listLocations"; input: LibraryArgs<string | null>; result: ExplorerItem[]; error: SdError } | { key: "notifications.dismiss"; input: NotificationId; result: null; error: SdError } | { key: "notifications.dismissAll"; input: never; result: null; error: SdError } | { key: "notifications.get"; input: never; result: Notification[]; error: SdError } | { key: "preferences.get"; input: LibraryArgs<null>; result: LibraryPreferences; error: SdError } | { key: "search.ephemeralPaths"; input: LibraryArgs<EphemeralPathSearchArgs>; result: NonIndexedFileSystemEntries; error: SdError } | { key: "search.objects"; input: LibraryArgs<ObjectSearchArgs>; result: SearchData<ExplorerItem>; error: SdError } | { key: "search.objectsCount"; input: LibraryArgs<{ filter?: ObjectFilterArgs }>; result: number; error: SdError } | { key: "search.paths"; input: LibraryArgs<FilePathSearchArgs>; result: SearchData<ExplorerItem>; error: SdError } | { key: "search.pathsCount"; input: LibraryArgs<{ filter?: FilePathFilterArgs }>; result: number; error: SdError } | { key: "sync.messages"; input: LibraryArgs<null>; result: CRDTOperation[]; error: SdError } | { key: "tags.get"; input: LibraryArgs<number>; result: { id: number; pub_id: number[]; name: string | null; color: string | null; redundancy_goal: number | null; date_created: string | null; date_modified: string | null } | null; error: SdError } | { key: "tags.getForObject"; input: LibraryArgs<number>; result: Tag[]; error: SdError } | { key: "tags.getWithObjects"; input: LibraryArgs<number[]>; result: { [key in number]: number[] }; error: SdError } | { key: "tags.list"; input: LibraryArgs<null>; result: Tag[]; error: SdError } | { key: "volumes.list"; input: never; result: Volume[]; error: SdError }; mutations: { key: "api.sendFeedback"; input: Feedback; result: null; error: SdError } | { key: "auth.logout"; input: never; result: null | { code: ErrorCode; message: string }; error: SdError } | { key: "backups.backup"; input: LibraryArgs<null>; result: string; error: SdError } | { key: "backups.delete"; input: string; result: null; error: SdError } | { key: "backups.restore"; input: string; result: null; error: SdError } | { key: "files.convertImage"; input: LibraryArgs<ConvertImageArgs>; result: null; error: SdError } | { key: "files.copyFiles"; input: LibraryArgs<FileCopierJobInit>; result: null; error: SdError } | { key: "files.createEphemeralFolder"; input: LibraryArgs<CreateEphemeralFolderArgs>; result: string; error: SdError } | { key: "files.createFolder"; input: LibraryArgs<CreateFolderArgs>; result: string; error: SdError } | { key: "files.cutFiles"; input: LibraryArgs<FileCutterJobInit>; result: null; error: SdError } | { key: "files.deleteFiles"; input: LibraryArgs<FileDeleterJobInit>; result: null; error: SdError } | { key: "files.duplicateFiles"; input: LibraryArgs<FileCopierJobInit>; result: null; error: SdError } | { key: "files.eraseFiles"; input: LibraryArgs<FileEraserJobInit>; result: null; error: SdError } | { key: "files.removeAccessTime"; input: LibraryArgs<number[]>; result: null; error: SdError } | { key: "files.renameFile"; input: LibraryArgs<RenameFileArgs>; result: null; error: SdError } | { key: "files.setFavorite"; input: LibraryArgs<SetFavoriteArgs>; result: null; error: SdError } | { key: "files.setNote"; input: LibraryArgs<SetNoteArgs>; result: null; error: SdError } | { key: "files.updateAccessTime"; input: LibraryArgs<number[]>; result: null; error: SdError } | { key: "invalidation.test-invalidate-mutation"; input: LibraryArgs<null>; result: null; error: SdError } | { key: "jobs.cancel"; input: LibraryArgs<string>; result: null; error: SdError } | { key: "jobs.clear"; input: LibraryArgs<string>; result: null; error: SdError } | { key: "jobs.clearAll"; input: LibraryArgs<null>; result: null; error: SdError } | { key: "jobs.generateThumbsForLocation"; input: LibraryArgs<GenerateThumbsForLocationArgs>; result: null; error: SdError } | { key: "jobs.identifyUniqueFiles"; input: LibraryArgs<IdentifyUniqueFilesArgs>; result: null; error: SdError } | { key: "jobs.objectValidator"; input: LibraryArgs<ObjectValidatorArgs>; result: null; error: SdError } | { key: "jobs.pause"; input: LibraryArgs<string>; result: null; error: SdError } | { key: "jobs.resume"; input: LibraryArgs<string>; result: null; error: SdError } | { key: "library.create"; input: CreateLibraryArgs; result: LibraryConfigWrapped; error: SdError } | { key: "library.delete"; input: string; result: null; error: SdError } | { key: "library.edit"; input: EditLibraryArgs; result: null; error: SdError } | { key: "locations.addLibrary"; input: LibraryArgs<LocationCreateArgs>; result: number | null; error: SdError } | { key: "locations.create"; input: LibraryArgs<LocationCreateArgs>; result: number | null; error: SdError } | { key: "locations.delete"; input: LibraryArgs<number>; result: null; error: SdError } | { key: "locations.fullRescan"; input: LibraryArgs<FullRescanArgs>; result: null; error: SdError } | { key: "locations.indexer_rules.create"; input: LibraryArgs<IndexerRuleCreateArgs>; result: null; error: SdError } | { key: "locations.indexer_rules.delete"; input: LibraryArgs<number>; result: null; error: SdError } | { key: "locations.relink"; input: LibraryArgs<string>; result: number; error: SdError } | { key: "locations.subPathRescan"; input: LibraryArgs<RescanArgs>; result: null; error: SdError } | { key: "locations.update"; input: LibraryArgs<LocationUpdateArgs>; result: null; error: SdError } | { key: "nodes.edit"; input: ChangeNodeNameArgs; result: null; error: SdError } | { key: "notifications.test"; input: never; result: null; error: SdError } | { key: "notifications.testLibrary"; input: LibraryArgs<null>; result: null; error: SdError } | { key: "p2p.acceptSpacedrop"; input: [string, string | null]; result: null; error: SdError } | { key: "p2p.cancelSpacedrop"; input: string; result: null; error: SdError } | { key: "p2p.pair"; input: RemoteIdentity; result: number; error: SdError } | { key: "p2p.pairingResponse"; input: [number, PairingDecision]; result: null; error: SdError } | { key: "p2p.spacedrop"; input: SpacedropArgs; result: string; error: SdError } | { key: "preferences.update"; input: LibraryArgs<LibraryPreferences>; result: null; error: SdError } | { key: "tags.assign"; input: LibraryArgs<{ targets: Target[]; tag_id: number; unassign: boolean }>; result: null; error: SdError } | { key: "tags.create"; input: LibraryArgs<TagCreateArgs>; result: Tag; error: SdError } | { key: "tags.delete"; input: LibraryArgs<number>; result: null; error: SdError } | { key: "tags.update"; input: LibraryArgs<TagUpdateArgs>; result: null; error: SdError } | { key: "toggleFeatureFlag"; input: BackendFeature; result: null; error: SdError }; subscriptions: { key: "auth.loginSession"; input: never; result: Response; error: SdError } | { key: "invalidation.listen"; input: never; result: InvalidateOperationEvent[]; error: SdError } | { key: "jobs.newThumbnail"; input: LibraryArgs<null>; result: string[]; error: SdError } | { key: "jobs.progress"; input: LibraryArgs<null>; result: JobProgressEvent; error: SdError } | { key: "locations.online"; input: never; result: number[][]; error: SdError } | { key: "notifications.listen"; input: never; result: Notification; error: SdError } | { key: "p2p.events"; input: never; result: P2PEvent; error: SdError } | { key: "sync.newMessage"; input: LibraryArgs<null>; result: null; error: SdError } }

export type AudioMetadata = { duration: number | null; audio_codec: string | null }

/**
 * All of the feature flags provided by the core itself. The frontend has it's own set of feature flags!
 *
 * If you want a variant of this to show up on the frontend it must be added to `backendFeatures` in `useFeatureFlag.tsx`
 */
export type BackendFeature = "syncEmitMessages" | "filesOverP2P"

export type Backup = ({ id: string; timestamp: string; library_id: string; library_name: string }) & { path: string }

export type BuildInfo = { version: string; commit: string }

export type CRDTOperation = { instance: string; timestamp: number; id: string; typ: CRDTOperationType }

export type CRDTOperationType = SharedOperation | RelationOperation

export type CameraData = { device_make: string | null; device_model: string | null; color_space: string | null; color_profile: ColorProfile | null; focal_length: number | null; shutter_speed: number | null; flash: Flash | null; orientation: Orientation; lens_make: string | null; lens_model: string | null; bit_depth: number | null; red_eye: boolean | null; zoom: number | null; iso: number | null; software: string | null; serial_number: string | null; lens_serial_number: string | null; contrast: number | null; saturation: number | null; sharpness: number | null; composite: Composite | null }

/**
 * Meow
 */
export type Category = "Recents" | "Favorites" | "Albums" | "Photos" | "Videos" | "Movies" | "Music" | "Documents" | "Downloads" | "Encrypted" | "Projects" | "Applications" | "Archives" | "Databases" | "Games" | "Books" | "Contacts" | "Trash" | "Screenshots"

export type ChangeNodeNameArgs = { name: string | null; p2p_enabled: boolean | null; p2p_port: MaybeUndefined<number> }

export type ColorProfile = "Normal" | "Custom" | "HDRNoOriginal" | "HDRWithOriginal" | "OriginalForHDR" | "Panorama" | "PortraitHDR" | "Portrait"

export type Composite =
/**
 * The data is present, but we're unable to determine what they mean
 */
"Unknown" |
/**
 * Not a composite image
 */
"False" |
/**
 * A general composite image
 */
"General" |
/**
 * The composite image was captured while shooting
 */
"Live"

export type ConvertImageArgs = { location_id: number; file_path_id: number; delete_src: boolean; desired_extension: ConvertableExtension; quality_percentage: number | null }

export type ConvertableExtension = "bmp" | "dib" | "ff" | "gif" | "ico" | "jpg" | "jpeg" | "png" | "pnm" | "qoi" | "tga" | "icb" | "vda" | "vst" | "tiff" | "tif" | "heif" | "heifs" | "heic" | "heics" | "avif" | "avci" | "avcs" | "svg" | "svgz" | "pdf" | "webp"

export type CreateEphemeralFolderArgs = { path: string; name: string | null }

export type CreateFolderArgs = { location_id: number; sub_path: string | null; name: string | null }

export type CreateLibraryArgs = { name: LibraryName; default_locations: DefaultLocations | null }

export type CursorOrderItem<T> = { order: SortOrder; data: string }

export type DefaultLocations = { desktop: boolean; documents: boolean; downloads: boolean; pictures: boolean; music: boolean; videos: boolean }

export type DiskType = "SSD" | "HDD" | "Removable"

export type DoubleClickAction = "openFile" | "quickPreview"

export type EditLibraryArgs = { id: string; name: LibraryName | null; description: MaybeUndefined<string> }

export type EphemeralPathOrder = { field: "name"; value: SortOrder } | { field: "sizeInBytes"; value: SortOrder } | { field: "dateCreated"; value: SortOrder } | { field: "dateModified"; value: SortOrder }

export type EphemeralPathSearchArgs = { path: string; withHiddenFiles: boolean; order?: EphemeralPathOrder | null }

export type Error = { code: ErrorCode; message: string }

/**
 * TODO
 */
export type ErrorCode = "BadRequest" | "Unauthorized" | "Forbidden" | "NotFound" | "Timeout" | "Conflict" | "PreconditionFailed" | "PayloadTooLarge" | "MethodNotSupported" | "ClientClosedRequest" | "InternalServerError"

export type ExplorerItem = { type: "Path"; has_local_thumbnail: boolean; thumbnail_key: string[] | null; item: FilePathWithObject } | { type: "Object"; has_local_thumbnail: boolean; thumbnail_key: string[] | null; item: ObjectWithFilePaths } | { type: "Location"; has_local_thumbnail: boolean; thumbnail_key: string[] | null; item: Location } | { type: "NonIndexedPath"; has_local_thumbnail: boolean; thumbnail_key: string[] | null; item: NonIndexedPathItem } | { type: "SpacedropPeer"; has_local_thumbnail: boolean; thumbnail_key: string[] | null; item: PeerMetadata }

export type ExplorerLayout = "grid" | "list" | "media"

export type ExplorerSettings<TOrder> = { layoutMode: ExplorerLayout | null; gridItemSize: number | null; gridGap: number | null; mediaColumns: number | null; mediaAspectSquare: boolean | null; mediaViewWithDescendants: boolean | null; openOnDoubleClick: DoubleClickAction | null; showBytesInGridView: boolean | null; colVisibility: { [key in string]: boolean } | null; colSizes: { [key in string]: number } | null; order?: FilePathOrder | null; showHiddenFiles?: boolean }

export type Feedback = { message: string; emoji: number }

export type FileCopierJobInit = { source_location_id: number; target_location_id: number; sources_file_path_ids: number[]; target_location_relative_directory_path: string }

export type FileCutterJobInit = { source_location_id: number; target_location_id: number; sources_file_path_ids: number[]; target_location_relative_directory_path: string }

export type FileDeleterJobInit = { location_id: number; file_path_ids: number[] }

export type FileEraserJobInit = { location_id: number; file_path_ids: number[]; passes: string }

export type FilePath = { id: number; pub_id: number[]; is_dir: boolean | null; cas_id: string | null; integrity_checksum: string | null; location_id: number | null; materialized_path: string | null; name: string | null; extension: string | null; hidden: boolean | null; size_in_bytes: string | null; size_in_bytes_bytes: number[] | null; inode: number[] | null; object_id: number | null; key_id: number | null; date_created: string | null; date_modified: string | null; date_indexed: string | null }

export type FilePathCursor = { isDir: boolean; variant: FilePathCursorVariant }

export type FilePathCursorVariant = "none" | { name: CursorOrderItem<string> } | { sizeInBytes: SortOrder } | { dateCreated: CursorOrderItem<string> } | { dateModified: CursorOrderItem<string> } | { dateIndexed: CursorOrderItem<string> } | { object: FilePathObjectCursor }

export type FilePathFilterArgs = { locationId?: number | null; search?: string | null; extension?: string | null; createdAt?: OptionalRange<string>; path?: string | null; withDescendants?: boolean | null; object?: ObjectFilterArgs | null; hidden?: boolean | null }

export type FilePathObjectCursor = { dateAccessed: CursorOrderItem<string> } | { kind: CursorOrderItem<number> }

export type FilePathOrder = { field: "name"; value: SortOrder } | { field: "sizeInBytes"; value: SortOrder } | { field: "dateCreated"; value: SortOrder } | { field: "dateModified"; value: SortOrder } | { field: "dateIndexed"; value: SortOrder } | { field: "object"; value: ObjectOrder } | { field: "dateImageTaken"; value: ObjectOrder }

export type FilePathSearchArgs = { take?: number | null; orderAndPagination?: OrderAndPagination<number, FilePathOrder, FilePathCursor> | null; filter?: FilePathFilterArgs; groupDirectories?: boolean }

export type FilePathWithObject = { id: number; pub_id: number[]; is_dir: boolean | null; cas_id: string | null; integrity_checksum: string | null; location_id: number | null; materialized_path: string | null; name: string | null; extension: string | null; hidden: boolean | null; size_in_bytes: string | null; size_in_bytes_bytes: number[] | null; inode: number[] | null; object_id: number | null; key_id: number | null; date_created: string | null; date_modified: string | null; date_indexed: string | null; object: { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null } | null }

export type Flash = {
/**
 * Specifies how flash was used (on, auto, off, forced, onvalid)
 *
 * [`FlashMode::Unknown`] isn't a valid EXIF state, but it's included as the default,
 * just in case we're unable to correctly match it to a known (valid) state.
 *
 * This type should only ever be evaluated if flash EXIF data is present, so having this as a non-option shouldn't be an issue.
 */
mode: FlashMode;
/**
 * Did the flash actually fire?
 */
fired: boolean | null;
/**
 * Did flash return to the camera? (Unsure of the meaning)
 */
returned: boolean | null;
/**
 * Was red eye reduction used?
 */
red_eye_reduction: boolean | null }

export type FlashMode =
/**
 * The data is present, but we're unable to determine what they mean
 */
"Unknown" |
/**
 * FLash was on
 */
"On" |
/**
 * Flash was off
 */
"Off" |
/**
 * Flash was set to automatically fire in certain conditions
 */
"Auto" |
/**
 * Flash was forcefully fired
 */
"Forced"

export type FromPattern = { pattern: string; replace_all: boolean }

export type FullRescanArgs = { location_id: number; reidentify_objects: boolean }

export type GenerateThumbsForLocationArgs = { id: number; path: string; regenerate?: boolean }

export type GetAll = { backups: Backup[]; directory: string }

export type GetArgs = { id: number }

export type Header = { id: string; timestamp: string; library_id: string; library_name: string }

export type IdentifyUniqueFilesArgs = { id: number; path: string }

export type ImageMetadata = { resolution: Resolution; date_taken: MediaDate | null; location: MediaLocation | null; camera_data: CameraData; artist: string | null; description: string | null; copyright: string | null; exif_version: string | null }

export type IndexerRule = { id: number; pub_id: number[]; name: string | null; default: boolean | null; rules_per_kind: number[] | null; date_created: string | null; date_modified: string | null }

/**
 * `IndexerRuleCreateArgs` is the argument received from the client using rspc to create a new indexer rule.
 * Note that `rules` field is a vector of tuples of `RuleKind` and `parameters`.
 *
 * In case of  `RuleKind::AcceptFilesByGlob` or `RuleKind::RejectFilesByGlob`, it will be a
 * vector of strings containing a glob patterns.
 *
 * In case of `RuleKind::AcceptIfChildrenDirectoriesArePresent` or `RuleKind::RejectIfChildrenDirectoriesArePresent` the
 * `parameters` field must be a vector of strings containing the names of the directories.
 */
export type IndexerRuleCreateArgs = { name: string; dry_run: boolean; rules: ([RuleKind, string[]])[] }

export type Infallible = never

export type InvalidateOperationEvent = { type: "single"; data: SingleInvalidateOperationEvent } | { type: "all" }

export type JobGroup = { id: string; action: string | null; status: JobStatus; created_at: string; jobs: JobReport[] }

export type JobProgressEvent = { id: string; library_id: string; task_count: number; completed_task_count: number; phase: string; message: string; estimated_completion: string }

export type JobReport = { id: string; name: string; action: string | null; data: number[] | null; metadata: { [key in string]: any } | null; is_background: boolean; errors_text: string[]; created_at: string | null; started_at: string | null; completed_at: string | null; parent_id: string | null; status: JobStatus; task_count: number; completed_task_count: number; phase: string; message: string; estimated_completion: string }

export type JobStatus = "Queued" | "Running" | "Completed" | "Canceled" | "Failed" | "Paused" | "CompletedWithErrors"

/**
 * Can wrap a query argument to require it to contain a `library_id` and provide helpers for working with libraries.
 */
export type LibraryArgs<T> = { library_id: string; arg: EphemeralPathSearchArgs }

/**
 * LibraryConfig holds the configuration for a specific library. This is stored as a '{uuid}.sdlibrary' file.
 */
export type LibraryConfig = {
/**
 * name is the display name of the library. This is used in the UI and is set by the user.
 */
name: LibraryName;
/**
 * description is a user set description of the library. This is used in the UI and is set by the user.
 */
description: string | null;
/**
 * id of the current instance so we know who this `.db` is. This can be looked up within the `Instance` table.
 */
instance_id: number }

export type LibraryConfigWrapped = { uuid: string; instance_id: string; instance_public_key: RemoteIdentity; config: LibraryConfig }

export type LibraryName = string

export type LibraryPreferences = { location?: { [key in string]: LocationSettings } }

export type Location = { id: number; pub_id: number[]; name: string | null; path: string | null; total_capacity: number | null; available_capacity: number | null; size_in_bytes: number[] | null; is_archived: boolean | null; generate_preview_media: boolean | null; sync_preview_media: boolean | null; hidden: boolean | null; date_created: string | null; instance_id: number | null }

/**
 * `LocationCreateArgs` is the argument received from the client using `rspc` to create a new location.
 * It has the actual path and a vector of indexer rules ids, to create many-to-many relationships
 * between the location and indexer rules.
 */
export type LocationCreateArgs = { path: string; dry_run: boolean; indexer_rules_ids: number[] }

export type LocationSettings = { explorer: ExplorerSettings<FilePathOrder> }

/**
 * `LocationUpdateArgs` is the argument received from the client using `rspc` to update a location.
 * It contains the id of the location to be updated, possible a name to change the current location's name
 * and a vector of indexer rules ids to add or remove from the location.
 *
 * It is important to note that only the indexer rule ids in this vector will be used from now on.
 * Old rules that aren't in this vector will be purged.
 */
export type LocationUpdateArgs = { id: number; name: string | null; generate_preview_media: boolean | null; sync_preview_media: boolean | null; hidden: boolean | null; indexer_rules_ids: number[]; path: string | null }

export type MaybeNot<T> = string | null | { not: string | null }

export type MaybeUndefined<T> = null | string

/**
 * This can be either naive with no TZ (`YYYY-MM-DD HH-MM-SS`) or UTC (`YYYY-MM-DD HH-MM-SS ±HHMM`),
 * where `±HHMM` is the timezone data. It may be negative if West of the Prime Meridian, or positive if East.
 */
export type MediaDate = string

export type MediaLocation = { latitude: number; longitude: number; pluscode: PlusCode; altitude: number | null; direction: number | null }

export type MediaMetadata = ({ type: "Image" } & ImageMetadata) | ({ type: "Video" } & VideoMetadata) | ({ type: "Audio" } & AudioMetadata)

export type NodeState = ({
/**
 * id is a unique identifier for the current node. Each node has a public identifier (this one) and is given a local id for each library (done within the library code).
 */
id: string;
/**
 * name is the display name of the current node. This is set by the user and is shown in the UI. // TODO: Length validation so it can fit in DNS record
 */
name: string; p2p_enabled: boolean; p2p_port: number | null; features: BackendFeature[] }) & { data_path: string }

export type NonIndexedFileSystemEntries = { entries: ExplorerItem[]; errors: Error[] }

export type NonIndexedPathItem = { path: string; name: string; extension: string; kind: number; is_dir: boolean; date_created: string; date_modified: string; size_in_bytes_bytes: number[]; hidden: boolean }

/**
 * Represents a single notification.
 */
export type Notification = ({ type: "library"; id: [string, number] } | { type: "node"; id: number }) & { data: NotificationData; read: boolean; expires: string | null }

/**
 * Represents the data of a single notification.
 * This data is used by the frontend to properly display the notification.
 */
export type NotificationData = { PairingRequest: { id: string; pairing_id: number } } | "Test"

export type NotificationId = { type: "library"; id: [string, number] } | { type: "node"; id: number }

export type ObjectCursor = "none" | { dateAccessed: CursorOrderItem<string> } | { kind: CursorOrderItem<number> }

export type ObjectFilterArgs = { favorite?: boolean | null; hidden?: ObjectHiddenFilter; dateAccessed?: MaybeNot<string | null> | null; kind?: number[]; tags?: number[]; category?: Category | null }

export type ObjectHiddenFilter = "exclude" | "include"

export type ObjectOrder = { field: "dateAccessed"; value: SortOrder } | { field: "kind"; value: SortOrder } | { field: "dateImageTaken"; value: SortOrder }

export type ObjectSearchArgs = { take: number; orderAndPagination?: OrderAndPagination<number, ObjectOrder, ObjectCursor> | null; filter?: ObjectFilterArgs }

export type ObjectValidatorArgs = { id: number; path: string }

export type ObjectWithFilePaths = { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; file_paths: FilePath[] }

/**
 * Represents the operating system which the remote peer is running.
 * This is not used internally and predominantly is designed to be used for display purposes by the embedding application.
 */
export type OperatingSystem = "Windows" | "Linux" | "MacOS" | "Ios" | "Android" | { Other: string }

export type OptionalRange<T> = { from: string | null; to: string | null }

export type OrderAndPagination<TId, TOrder, TCursor> = { orderOnly: FilePathOrder } | { offset: { offset: number; order: FilePathOrder | null } } | { cursor: { id: number; cursor: FilePathCursor } }

export type Orientation = "Normal" | "CW90" | "CW180" | "CW270" | "MirroredVertical" | "MirroredHorizontal" | "MirroredHorizontalAnd90CW" | "MirroredHorizontalAnd270CW"

/**
 * TODO: P2P event for the frontend
 */
export type P2PEvent = { type: "DiscoveredPeer"; identity: RemoteIdentity; metadata: PeerMetadata } | { type: "ExpiredPeer"; identity: RemoteIdentity } | { type: "ConnectedPeer"; identity: RemoteIdentity } | { type: "DisconnectedPeer"; identity: RemoteIdentity } | { type: "SpacedropRequest"; id: string; identity: RemoteIdentity; peer_name: string; files: string[] } | { type: "SpacedropProgress"; id: string; percent: number } | { type: "SpacedropTimedout"; id: string } | { type: "SpacedropRejected"; id: string } | { type: "PairingRequest"; id: number; name: string; os: OperatingSystem } | { type: "PairingProgress"; id: number; status: PairingStatus }

export type PairingDecision = { decision: "accept"; libraryId: string } | { decision: "reject" }

export type PairingStatus = { type: "EstablishingConnection" } | { type: "PairingRequested" } | { type: "LibraryAlreadyExists" } | { type: "PairingDecisionRequest" } | { type: "PairingInProgress"; data: { library_name: string; library_description: string | null } } | { type: "InitialSyncProgress"; data: number } | { type: "PairingComplete"; data: string } | { type: "PairingRejected" }

export type PeerMetadata = { name: string; operating_system: OperatingSystem | null; version: string | null }

export type PlusCode = string

export type RelationOperation = { relation_item: any; relation_group: any; relation: string; data: RelationOperationData }

export type RelationOperationData = "c" | { u: { field: string; value: any } } | "d"

export type RemoteIdentity = string

export type RenameFileArgs = { location_id: number; kind: RenameKind }

export type RenameKind = { One: RenameOne } | { Many: RenameMany }

export type RenameMany = { from_pattern: FromPattern; to_pattern: string; from_file_path_ids: number[] }

export type RenameOne = { from_file_path_id: number; to: string }

export type RescanArgs = { location_id: number; sub_path: string }

export type Resolution = { width: number; height: number }

export type Response = { Start: { user_code: string; verification_url: string; verification_url_complete: string } } | "Complete" | "Error"

export type RuleKind = "AcceptFilesByGlob" | "RejectFilesByGlob" | "AcceptIfChildrenDirectoriesArePresent" | "RejectIfChildrenDirectoriesArePresent"

export type SanitisedNodeConfig = {
/**
 * id is a unique identifier for the current node. Each node has a public identifier (this one) and is given a local id for each library (done within the library code).
 */
id: string;
/**
 * name is the display name of the current node. This is set by the user and is shown in the UI. // TODO: Length validation so it can fit in DNS record
 */
name: string; p2p_enabled: boolean; p2p_port: number | null; features: BackendFeature[] }

export type SdError = "Prisma" | { Rspc: Error } | "LocationError" | "NonIndexedLocationError" | "LibraryManagerError" | "JobManagerError" | "IndexerRuleError" | "FileIOError" | "MissingFieldError" | "SdImagesError" | { Infallible: Infallible }

export type SearchData<T> = { cursor: number[] | null; items: ExplorerItem[] }

export type SetFavoriteArgs = { id: number; favorite: boolean }

export type SetNoteArgs = { id: number; note: string | null }

export type SharedOperation = { record_id: any; model: string; data: SharedOperationData }

export type SharedOperationData = "c" | { u: { field: string; value: any } } | "d"

export type SingleInvalidateOperationEvent = {
/**
 * This fields are intentionally private.
 */
key: string; arg: any; result: any | null }

export type SortOrder = "Asc" | "Desc"

export type SpacedropArgs = { identity: RemoteIdentity; file_path: string[] }

export type Statistics = { id: number; date_captured: string; total_object_count: number; library_db_size: string; total_bytes_used: string; total_bytes_capacity: string; total_unique_bytes: string; total_bytes_free: string; preview_media_bytes: string }

export type SystemLocations = { desktop: string | null; documents: string | null; downloads: string | null; pictures: string | null; music: string | null; videos: string | null }

export type Tag = { id: number; pub_id: number[]; name: string | null; color: string | null; redundancy_goal: number | null; date_created: string | null; date_modified: string | null }

export type TagCreateArgs = { name: string; color: string }

export type TagUpdateArgs = { id: number; name: string | null; color: string | null }

export type Target = { Object: number } | { FilePath: number }

export type VideoMetadata = { duration: number | null; video_codec: string | null; audio_codec: string | null }

export type Volume = { name: string; mount_points: string[]; total_capacity: string; available_capacity: string; disk_type: DiskType; file_system: string | null; is_root_filesystem: boolean }
